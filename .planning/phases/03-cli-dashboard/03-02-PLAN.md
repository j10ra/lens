---
phase: 03-cli-dashboard
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/dashboard/package.json
  - apps/dashboard/index.html
  - apps/dashboard/vite.config.ts
  - apps/dashboard/tsconfig.json
  - apps/dashboard/components.json
  - apps/dashboard/src/main.tsx
  - apps/dashboard/src/globals.css
  - apps/dashboard/src/router.tsx
  - apps/dashboard/src/lib/api.ts
  - apps/dashboard/src/lib/utils.ts
  - apps/dashboard/src/store/repo-store.ts
  - apps/dashboard/src/store/trace-store.ts
  - apps/dashboard/src/components/AppSidebar.tsx
  - apps/dashboard/src/components/Logo.tsx
  - apps/dashboard/src/components/PageHeader.tsx
  - apps/dashboard/src/components/StatusBadge.tsx
  - apps/dashboard/src/components/RootLayout.tsx
  - apps/dashboard/src/queries/use-repos.ts
  - apps/dashboard/src/queries/use-traces.ts
  - apps/dashboard/src/pages/Overview.tsx
  - packages/core/src/trace-store.ts
  - packages/core/src/index.ts
  - apps/daemon/src/routes/traces.ts
  - apps/daemon/src/routes/files.ts
  - apps/daemon/src/http.ts
autonomous: true
requirements: [DASH-01, DASH-04, DASH-05, DASH-06]

must_haves:
  truths:
    - "pnpm --filter @lens/dashboard dev starts Vite dev server on port 5173"
    - "pnpm --filter @lens/dashboard build produces dist/ with index.html and assets"
    - "Dashboard uses shadcn/ui components (Badge, Button, Card, Sheet, Table, Sidebar primitives)"
    - "All daemon API calls go through TanStack Query hooks (useQuery, useMutation)"
    - "Client-side UI state uses TanStack Store (repoStore, traceStore) with selectors"
    - "Dashboard layout matches v1: SidebarProvider > AppSidebar + SidebarInset with floating card"
    - "Overview page shows stat cards and repo grid matching v1 design"
    - "GET /traces endpoint returns recent traces from TraceStore"
    - "GET /traces/:traceId endpoint returns spans for a specific trace"
    - "GET /repos/:id/files endpoint returns file metadata with structural context"
  artifacts:
    - path: "apps/dashboard/src/main.tsx"
      provides: "React entry point with QueryClientProvider and RouterProvider"
      min_lines: 15
    - path: "apps/dashboard/src/router.tsx"
      provides: "react-router v7 routes"
    - path: "apps/dashboard/src/lib/api.ts"
      provides: "DAEMON_URL constant and typed fetch wrappers"
      exports: ["DAEMON_URL", "api"]
    - path: "apps/dashboard/src/store/repo-store.ts"
      provides: "TanStack Store for repo UI state"
      exports: ["repoStore", "useSelectedRepoId"]
    - path: "apps/dashboard/src/store/trace-store.ts"
      provides: "TanStack Store for trace UI state"
      exports: ["traceStore", "useSelectedTraceId"]
    - path: "apps/dashboard/src/components/RootLayout.tsx"
      provides: "Root layout with sidebar matching v1 design"
    - path: "apps/dashboard/src/pages/Overview.tsx"
      provides: "Overview page with stat cards and repo grid"
    - path: "packages/core/src/trace-store.ts"
      provides: "queryTraces and querySpans methods"
    - path: "apps/daemon/src/routes/traces.ts"
      provides: "GET /traces and GET /traces/:traceId"
    - path: "apps/daemon/src/routes/files.ts"
      provides: "GET /repos/:id/files and GET /repos/:id/files/:path"
  key_links:
    - from: "apps/dashboard/src/main.tsx"
      to: "apps/dashboard/src/router.tsx"
      via: "RouterProvider"
      pattern: "RouterProvider.*router"
    - from: "apps/dashboard/src/queries/use-repos.ts"
      to: "apps/dashboard/src/lib/api.ts"
      via: "DAEMON_URL fetch"
      pattern: "DAEMON_URL"
    - from: "apps/daemon/src/routes/traces.ts"
      to: "packages/core/src/trace-store.ts"
      via: "getTraceStore()"
      pattern: "getTraceStore"
    - from: "apps/daemon/src/http.ts"
      to: "apps/daemon/src/routes/traces.ts"
      via: "app.route"
      pattern: "app\\.route.*traces"
---

<objective>
Scaffold the complete dashboard SPA with shadcn/ui, TanStack Query/Store, router, daemon API client, shared components, Overview page, AND daemon routes for traces and files.

Purpose: Establish the full dashboard foundation (matching v1 design) plus all daemon endpoints the dashboard needs, so Plans 03 and 04 can build pages on top without any infrastructure work.
Output: Working Vite dev server with sidebar layout, Overview page, all shared components, TanStack Query hooks, stores, daemon trace/file routes.
</objective>

<execution_context>
@/Users/jalipalo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jalipalo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-cli-dashboard/03-RESEARCH.md
@apps/dashboard/package.json
@apps/daemon/src/http.ts
@apps/daemon/src/index.ts
@packages/core/src/trace-store.ts
@packages/core/src/index.ts
@packages/engine/src/index.ts
@packages/engine/src/db/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dashboard scaffold — deps, config, shadcn, shared components, layout, Overview page</name>
  <files>
    apps/dashboard/package.json
    apps/dashboard/index.html
    apps/dashboard/vite.config.ts
    apps/dashboard/tsconfig.json
    apps/dashboard/components.json
    apps/dashboard/src/main.tsx
    apps/dashboard/src/globals.css
    apps/dashboard/src/router.tsx
    apps/dashboard/src/lib/api.ts
    apps/dashboard/src/lib/utils.ts
    apps/dashboard/src/store/repo-store.ts
    apps/dashboard/src/store/trace-store.ts
    apps/dashboard/src/components/AppSidebar.tsx
    apps/dashboard/src/components/Logo.tsx
    apps/dashboard/src/components/PageHeader.tsx
    apps/dashboard/src/components/StatusBadge.tsx
    apps/dashboard/src/components/RootLayout.tsx
    apps/dashboard/src/queries/use-repos.ts
    apps/dashboard/src/queries/use-traces.ts
    apps/dashboard/src/pages/Overview.tsx
  </files>
  <action>
**1. Install dependencies:**
```
pnpm --filter @lens/dashboard add react react-dom react-router @tanstack/react-query @tanstack/react-query-devtools @tanstack/react-store lucide-react
pnpm --filter @lens/dashboard add -D vite @vitejs/plugin-react tailwindcss @tailwindcss/vite typescript @types/react @types/react-dom
```

**2. Config files:**

`vite.config.ts` — Tailwind v4 via `@tailwindcss/vite` plugin, `@vitejs/plugin-react`, path alias `@` -> `./src`. See research Pattern 3.

`tsconfig.json`:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "jsx": "react-jsx",
    "strict": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": { "@/*": ["./src/*"] },
    "noEmit": true
  },
  "include": ["src"]
}
```

`index.html` — standard Vite React SPA template: `<div id="root"></div>`, `<script type="module" src="/src/main.tsx"></script>`.

`components.json` — shadcn config for Vite:
```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": { "config": "", "css": "src/globals.css", "baseColor": "neutral", "cssVariables": true },
  "aliases": { "components": "@/components", "utils": "@/lib/utils", "ui": "@/components/ui", "lib": "@/lib", "hooks": "@/hooks" }
}
```

**3. Run `npx shadcn init` then add required components:**
```
npx shadcn@latest add badge button card separator sheet table tabs switch sidebar
```
This creates `src/components/ui/` with all shadcn primitives.

**4. `src/globals.css`** — replicate v1 theme. Use `@import "tailwindcss"` (v4), then OKLCH CSS variables for light/dark. Copy the EXACT v1 theme variables from `git show v1-archive:packages/ui/src/globals.css` — includes `--success`, `--warning` custom properties, dark-first OKLCH palette, `@theme inline` block with `--font-sans: "Inter Variable"`. Add `@import "@fontsource-variable/inter"` (install via pnpm). Do NOT create `tailwind.config.ts` — v4 uses plugin only.

**5. `src/lib/utils.ts`** — standard shadcn `cn()` utility (clsx + tailwind-merge). Also add `timeAgo(date)` and `formatDuration(ms)` helpers matching v1.

**6. `src/lib/api.ts`** — export `DAEMON_URL = "http://localhost:4111"`. Export `api` object with typed fetch wrappers. v2 API paths differ from v1:
- `api.health()` -> GET `/health`
- `api.repos()` -> GET `/repos` (returns array, not `{ repos: [...] }`)
- `api.stats()` -> GET `/stats` (new route, simple daemon-level stats)
- `api.traces(limit?)` -> GET `/traces?limit=N`
- `api.traceSpans(traceId)` -> GET `/traces/{traceId}`
- `api.repoFiles(id, params?)` -> GET `/repos/{id}/files?limit=N&offset=N&search=S`
- `api.repoFileDetail(repoId, filePath)` -> GET `/repos/{repoId}/files/{encodeURIComponent(filePath)}`
- `api.reindex(repoId)` -> POST `/repos/{repoId}/index`
- `api.registerRepo(rootPath, name?)` -> POST `/repos` with `{ path, name }`
- `api.removeRepo(id)` -> DELETE `/repos/{id}`

All fetch wrappers check `res.ok` and throw on non-2xx per research anti-patterns.

**7. TanStack Store:**

`src/store/repo-store.ts` — `createStore({ selectedRepoId: null, selectedFilePath: null })`. Export selector hooks `useSelectedRepoId()`, `useSelectedFilePath()` and mutators `selectRepo(id)`, `selectFile(path)`. Always use selector in `useStore()` — never bare `useStore(store)`.

`src/store/trace-store.ts` — `createStore({ selectedTraceId: null, filterText: "" })`. Export `useSelectedTraceId()`, `useTraceFilter()`, `selectTrace(id)`, `setTraceFilter(text)`.

**8. TanStack Query hooks:**

`src/queries/use-repos.ts` — `useRepos()` hook: `queryKey: ["repos"]`, calls `api.repos()`, `refetchInterval: 10_000`. Export `Repo` type.

`src/queries/use-traces.ts` — `useTraces(limit?)` hook: `queryKey: ["traces", limit]`, calls `api.traces(limit)`, `refetchInterval: 5_000`. `useTraceSpans(traceId)` hook: `queryKey: ["trace-spans", traceId]`, calls `api.traceSpans(traceId)`, `enabled: !!traceId`.

**9. Shared components (port from v1, adapt for v2):**

`src/components/Logo.tsx` — EXACT copy of v1 Logo: "L" square, `bg-primary`, health indicator. Remove `@lens/ui` import, use local `cn()`.

`src/components/PageHeader.tsx` — EXACT copy of v1 PageHeader: h-12, border-b, backdrop-blur, SidebarTrigger + Separator + children. Import Separator and SidebarTrigger from `@/components/ui/`.

`src/components/StatusBadge.tsx` — EXACT copy of v1 StatusBadge: Badge with color variants for ready/indexing/pending/error/active/inactive. Import Badge and cn from local paths.

`src/components/AppSidebar.tsx` — Port v1 AppSidebar but simplified for v2 (no cloud groups, no primary action). Keep the sidebar structure: `Sidebar collapsible="icon"` with SidebarHeader (Logo), SidebarContent (nav items), connection badge area. v2 nav items: Overview (/), Repos (/repos), Traces (/traces). No Cloud section. Import all sidebar primitives from `@/components/ui/sidebar`. The `renderLink` prop pattern stays the same — render using react-router `Link`. Add `ModeToggle` component (dark/light switch) matching v1.

Also create `src/components/ModeToggle.tsx` — simple dark mode toggle. On click: toggle `document.documentElement.classList.toggle("dark")`. Use `Moon`/`Sun` icons from lucide-react.

`src/components/RootLayout.tsx` — Port v1 RootLayout:
```tsx
<SidebarProvider className="bg-muted h-svh">
  <AppSidebar navItems={NAV_ITEMS} currentPath={location.pathname} renderLink={...} healthy={isHealthy} />
  <SidebarInset className="bg-background rounded-xl overflow-hidden md:my-2 md:mr-2 md:border">
    <div className="@container/main flex min-h-0 flex-1 flex-col">
      <Outlet />
    </div>
  </SidebarInset>
</SidebarProvider>
```
Use `useLocation()` from react-router for currentPath. Use `Link` from react-router in renderLink prop. Use `useQuery` for health check to set `isHealthy`. NAV_ITEMS: Overview (LayoutDashboard, "/"), Repos (FolderGit2, "/repos"), Traces (Activity, "/traces"). Import `SidebarProvider`, `SidebarInset` from `@/components/ui/sidebar`.

**10. Router (`src/router.tsx`):**
Use react-router v7 — import from `"react-router"` NOT `"react-router-dom"`. `createBrowserRouter` with routes:
- `/` -> RootLayout (parent) -> Overview (index)
- `/repos` -> Repos (placeholder div for now)
- `/repos/:repoId` -> RepoDetail (placeholder div for now)
- `/traces` -> Traces (placeholder div for now)

**11. Main entry (`src/main.tsx`):**
```tsx
const queryClient = new QueryClient({
  defaultOptions: { queries: { staleTime: 5_000, refetchOnWindowFocus: true, retry: 2 } },
});
// QueryClient at module level (NOT inside component body — research Pitfall 7)
ReactDOM.createRoot(root).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <RouterProvider router={router} />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  </StrictMode>
);
```

**12. Overview page (`src/pages/Overview.tsx`):**
Port v1 Overview page, adapted for v2 data:
- Stat cards in `@container/main` responsive grid (`@xl/main:grid-cols-2 @3xl/main:grid-cols-4`)
- Cards: Repos (count), Files (total indexed), Chunks (total), Uptime
- Remove v1 cloud-only cards (Embeddings, Summaries, Vocab, DB Size) and Pro upsell
- Repo grid below stats: card per repo with name, path, StatusBadge, file/chunk counts, last indexed time
- Click repo card navigates to `/repos/{id}`
- Use `useRepos()` hook for data, `useQuery` for stats/health
- EXACT v1 styling: `Card` with `border-border bg-background py-4 shadow-none`, stat labels uppercase tracking-wide, icon in `rounded-md border p-1.5`
- PageHeader with "Overview" text

Add a `GET /stats` route to daemon (in `apps/daemon/src/routes/health.ts` or as separate stats route) that returns `{ repos_count, total_files, total_chunks, uptime_seconds }` by querying engine DB. This is simpler than v1's dashboard-specific stats endpoint — just count from repos/chunks/file_metadata tables.
  </action>
  <verify>
1. `pnpm install` succeeds (new deps)
2. `pnpm --filter @lens/dashboard build` produces `dist/index.html`
3. `pnpm --filter @lens/daemon build` succeeds (new routes)
4. `pnpm --filter @lens/core build` succeeds (new TraceStore methods)
  </verify>
  <done>
Dashboard builds with Vite. shadcn/ui components available. RootLayout with sidebar matching v1 design. Overview page shows stat cards and repo grid. TanStack Query hooks and Store instances wired. Daemon has /traces and /repos/:id/files routes. All builds pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: TraceStore query methods, getTraceStore singleton, daemon trace + file routes</name>
  <files>
    packages/core/src/trace-store.ts
    packages/core/src/index.ts
    apps/daemon/src/routes/traces.ts
    apps/daemon/src/routes/files.ts
    apps/daemon/src/http.ts
  </files>
  <action>
**1. Add query methods to TraceStore (`packages/core/src/trace-store.ts`):**

Add `queryTraces(limit = 50)` method:
```typescript
queryTraces(limit = 50) {
  return this.sqlite
    .prepare("SELECT * FROM traces ORDER BY started_at DESC LIMIT ?")
    .all(limit) as Array<{
      trace_id: string; root_span_name: string;
      started_at: number; ended_at: number; duration_ms: number;
    }>;
}
```

Add `querySpans(traceId: string)` method:
```typescript
querySpans(traceId: string) {
  return this.sqlite
    .prepare("SELECT * FROM spans WHERE trace_id = ? ORDER BY started_at ASC")
    .all(traceId) as SpanRecord[];
}
```

**2. Add `getTraceStore` singleton to `trace-store.ts`:**

Add module-level `_instance` variable. Modify `createTraceStore()` to set `_instance`. Add `getTraceStore()` that returns `_instance` or throws if not initialized. This follows the existing `getEngineDb()`/`configureEngineDb()` singleton pattern from engine package.

**3. Export from `packages/core/src/index.ts`:**
Add `getTraceStore` to the export list.

**4. Rebuild core:**
`pnpm --filter @lens/core build`

**5. Create `apps/daemon/src/routes/traces.ts`:**
```typescript
import { getTraceStore, lensRoute } from "@lens/core";
import { Hono } from "hono";

export const tracesRoutes = new Hono();

// GET /traces — list recent traces
tracesRoutes.get("/", lensRoute("traces.list", async (c) => {
  const limit = Number(c.req.query("limit") ?? "50");
  const traces = getTraceStore().queryTraces(limit);
  return c.json(traces);
}));

// GET /traces/:traceId — spans for one trace
tracesRoutes.get("/:traceId", lensRoute("traces.get", async (c) => {
  const { traceId } = c.req.param();
  const spans = getTraceStore().querySpans(traceId);
  if (!spans.length) return c.json({ error: "trace not found" }, 404);
  return c.json({ traceId, spans });
}));
```

**6. Create `apps/daemon/src/routes/files.ts`:**
```typescript
import { lensRoute } from "@lens/core";
import { getEngineDb } from "@lens/engine";
import { Hono } from "hono";
```
- `GET /repos/:repoId/files` — query `file_metadata` for given repo. Support `?limit=100&offset=0&search=term`. Return `{ files: [...], total }`. Each file has: path, language, exports (JSON parsed), chunk_count (subquery on chunks table), import_count (count of file_imports where target_path matches). Use raw SQL via `getEngineDb().all(...)` for the join query.
- `GET /repos/:repoId/files/:filePath` — query single file metadata + imports (file_imports where source_path=filePath) + imported_by (file_imports where target_path=filePath) + git stats (file_stats) + cochanges (file_cochanges both directions). Return full structural context for file detail sheet.

**7. Wire routes in `apps/daemon/src/http.ts`:**
Import `tracesRoutes` and `filesRoutes`. Mount BEFORE any future serveStatic (API routes first — research Pitfall 1):
```typescript
app.route("/traces", tracesRoutes);
// filesRoutes is a sub-router mounted on repos since paths are /repos/:id/files
app.route("/repos", filesRoutes);
```
Note: filesRoutes handlers define paths relative to mount point. Since repos routes already exist at `/repos`, the files routes should be ADDED to the existing reposRoutes file, OR mounted as a separate sub-app. Recommended: add file routes directly to `apps/daemon/src/routes/repos.ts` since they share the `/repos` prefix. Alternatively, create files.ts with full `/repos/:repoId/files` paths and mount on root. Choose whichever avoids route conflicts — if adding to repos.ts is cleaner (fewer files), do that.

Also add a `GET /stats` handler (either in health.ts or a new stats route):
- Returns `{ repos_count, total_files, total_chunks, uptime_seconds }`
- `repos_count`: count from repos table
- `total_files`: count from file_metadata table
- `total_chunks`: count from chunks table
- `uptime_seconds`: `Math.floor(process.uptime())`
  </action>
  <verify>
1. `pnpm --filter @lens/core build` succeeds
2. `pnpm --filter @lens/daemon build` succeeds
3. grep for `getTraceStore` in core/src/index.ts confirms export
4. grep for `tracesRoutes` in daemon/src/http.ts confirms route mount
  </verify>
  <done>
TraceStore has queryTraces/querySpans methods. getTraceStore singleton exported from @lens/core. Daemon has GET /traces, GET /traces/:id, GET /repos/:id/files, GET /repos/:id/files/:path, and GET /stats routes. All builds pass.
  </done>
</task>

</tasks>

<verification>
- `pnpm -r build` — all packages build clean
- `apps/dashboard/dist/index.html` exists after build
- Dashboard dev server starts: `pnpm --filter @lens/dashboard dev`
- Daemon builds with new routes: traces, files, stats
- Core exports getTraceStore
</verification>

<success_criteria>
Dashboard SPA scaffold complete with v1-matching layout, Overview page, all shared components. Daemon has all API endpoints the dashboard needs (traces, files, stats). TanStack Query hooks and Store instances are wired. Both dashboard and daemon build clean.
</success_criteria>

<output>
After completion, create `.planning/phases/03-cli-dashboard/03-02-SUMMARY.md`
</output>
