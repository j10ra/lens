---
phase: 01-core-daemon-mcp
plan: "02"
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/daemon/package.json
  - apps/daemon/tsconfig.json
  - apps/daemon/tsup.config.ts
  - apps/daemon/src/index.ts
  - apps/daemon/src/http.ts
  - apps/daemon/src/mcp.ts
  - apps/daemon/src/routes/health.ts
autonomous: true
requirements:
  - DAEM-01
  - DAEM-02
  - DAEM-04

must_haves:
  truths:
    - "curl http://localhost:4111/health returns 200 JSON with status and uptime fields"
    - "All HTTP route handlers are wrapped in lensRoute() — grep for naked Hono handler patterns returns empty"
    - "The MCP server connects via stdio without crashing the HTTP server"
    - "No write to process.stdout in daemon src/ — all output goes to process.stderr or TraceStore"
    - "HTTP and MCP stdio run in the same process (single node invocation)"
    - "lensRoute() traces appear in TraceStore after an HTTP request"
  artifacts:
    - path: "apps/daemon/src/index.ts"
      provides: "Entry point starting HTTP + MCP"
      exports: []
    - path: "apps/daemon/src/http.ts"
      provides: "Hono app with health route"
      exports: ["app"]
    - path: "apps/daemon/src/mcp.ts"
      provides: "MCP stdio server with lens_grep tool stub"
      exports: ["startMcpServer"]
    - path: "apps/daemon/src/routes/health.ts"
      provides: "GET /health handler wrapped in lensRoute()"
      exports: ["healthRoutes"]
  key_links:
    - from: "apps/daemon/src/index.ts"
      to: "apps/daemon/src/http.ts"
      via: "startHttpServer() call"
      pattern: "startHttpServer|serve"
    - from: "apps/daemon/src/index.ts"
      to: "apps/daemon/src/mcp.ts"
      via: "startMcpServer() call (awaited)"
      pattern: "startMcpServer"
    - from: "apps/daemon/src/routes/health.ts"
      to: "@lens/core lensRoute"
      via: "lensRoute() wrapping every handler"
      pattern: "lensRoute"
---

<objective>
Build the `@lens/daemon` skeleton: Hono HTTP server on :4111 with health route, MCP stdio server with a stub `lens_grep` tool, all routes wrapped in lensRoute(), no stdout writes.

Purpose: Establishes the HTTP + MCP process shape that Phase 2 engine routes plug into. The tool stub in plan 02 exists to support the adoption benchmark in plan 04 — it must be discoverable and callable even if its response is minimal.
Output: `apps/daemon/dist/index.js` — a Node.js process that serves HTTP on :4111 and MCP on stdio simultaneously.
</objective>

<execution_context>
@/Users/jalipalo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jalipalo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-daemon-mcp/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Daemon package scaffold — deps, tsconfig, tsup</name>
  <files>
    apps/daemon/package.json
    apps/daemon/tsconfig.json
    apps/daemon/tsup.config.ts
  </files>
  <action>
Update `apps/daemon/package.json`:
```json
{
  "name": "@lens/daemon",
  "version": "2.0.0",
  "private": true,
  "type": "module",
  "main": "./dist/index.js",
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "start": "node dist/index.js",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@lens/core": "workspace:*",
    "@modelcontextprotocol/sdk": "^1.26.0",
    "hono": "^4.11.10",
    "@hono/node-server": "^1.19.9",
    "zod": "^3.24.0"
  },
  "devDependencies": {
    "tsup": "^8.5.0",
    "typescript": "^5.7.0"
  }
}
```

Create `apps/daemon/tsconfig.json`:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "strict": true,
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src"]
}
```

Create `apps/daemon/tsup.config.ts`:
```typescript
import { defineConfig } from 'tsup'

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['esm'],
  // No CJS needed — daemon is a Node process, not a library
  // No createRequire banner needed — core package handles better-sqlite3 internally
  dts: false,
  splitting: false,
  clean: true,
  // Externalize workspace packages — they ship their own builds
  external: ['@lens/core'],
})
```

Run `pnpm install` from repo root.
  </action>
  <verify>
    `cat apps/daemon/package.json` shows `@modelcontextprotocol/sdk`, `hono`, `@hono/node-server`, `zod`.
    `apps/daemon/tsup.config.ts` exists with `format: ['esm']`.
  </verify>
  <done>Daemon package.json, tsconfig.json, and tsup.config.ts exist with correct content. Deps installed.</done>
</task>

<task type="auto">
  <name>Task 2: Daemon implementation — HTTP server, MCP server, health route</name>
  <files>
    apps/daemon/src/routes/health.ts
    apps/daemon/src/http.ts
    apps/daemon/src/mcp.ts
    apps/daemon/src/index.ts
  </files>
  <action>
Create files in dependency order: health route → http → mcp → index.

**`apps/daemon/src/routes/health.ts`** — GET /health, wrapped in lensRoute():
```typescript
import { Hono } from 'hono'
import { lensRoute } from '@lens/core'

const startedAt = Date.now()

export const healthRoutes = new Hono()

healthRoutes.get(
  '/',
  lensRoute('health.get', async (c) => {
    return c.json({
      status: 'ok',
      uptime: Math.floor((Date.now() - startedAt) / 1000),
      version: '2.0.0',
    })
  })
)
```

**`apps/daemon/src/http.ts`** — Hono app with error handler and route mounting:
```typescript
import { Hono } from 'hono'
import { HTTPException } from 'hono/http-exception'
import { serve } from '@hono/node-server'
import { healthRoutes } from './routes/health.js'

export const app = new Hono()

app.onError((err, c) => {
  if (err instanceof HTTPException) return err.getResponse()
  // stderr — never stdout
  process.stderr.write(`[daemon] unhandled error: ${err.message}\n`)
  return c.json({ error: 'Internal server error' }, 500)
})

app.route('/health', healthRoutes)

export function startHttpServer(): void {
  serve({ fetch: app.fetch, port: 4111 }, (info) => {
    process.stderr.write(`[daemon] HTTP server listening on :${info.port}\n`)
  })
}
```

**`apps/daemon/src/mcp.ts`** — MCP stdio server with stub lens_grep tool:

The tool must be real enough that an agent can discover and invoke it. Response can be minimal in Phase 1 — Phase 2 connects it to the full engine.

Tool description follows the verb-first formula: action + noun + what it returns. Parameters use rich Zod `.describe()` so agents know exactly what to pass.

```typescript
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'
import { z } from 'zod'

export async function startMcpServer(): Promise<void> {
  const server = new McpServer({
    name: 'lens',
    version: '2.0.0',
  })

  server.registerTool(
    'lens_grep',
    {
      title: 'LENS Context Query',
      // Verb-first, 1-2 sentences. Operational detail in parameter .describe() — not here.
      description:
        'Query a codebase by keyword and get structural context: which files match, their importers, co-change partners, and hub scores. Use this when you need to understand where a symbol or concept lives in the repo graph.',
      inputSchema: {
        repoPath: z
          .string()
          .describe('Absolute path to the repository root (e.g. /Users/dev/myproject)'),
        query: z
          .string()
          .describe(
            'Search terms space-separated. All terms matched with AND logic. Example: "authMiddleware validate token"'
          ),
        limit: z
          .number()
          .int()
          .min(1)
          .max(50)
          .optional()
          .default(20)
          .describe('Max results to return. Default 20, max 50.'),
      },
    },
    async ({ repoPath, query, limit }) => {
      // Phase 1 stub — Phase 2 replaces this with real engine query
      // Daemon is not running an engine yet; return structured placeholder
      const response = {
        repoPath,
        query,
        limit,
        results: [],
        note: 'LENS engine not yet indexed. Run `lens register <path>` then `lens index` to populate.',
      }

      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify(response, null, 2),
          },
        ],
      }
    }
  )

  const transport = new StdioServerTransport()
  // connect() takes over stdin/stdout for JSON-RPC — must be last thing called
  await server.connect(transport)
}
```

**`apps/daemon/src/index.ts`** — Entry point wiring TraceStore + HTTP + MCP:
```typescript
import { createTraceStore, configureLensFn, configureLensRoute, configureLogger } from '@lens/core'
import { startHttpServer } from './http.js'
import { startMcpServer } from './mcp.js'
import { join } from 'node:path'
import { homedir } from 'node:os'

const DATA_DIR = process.env['LENS_DATA_DIR'] ?? join(homedir(), '.lens')
const TRACE_DB = join(DATA_DIR, 'traces.db')
const JSON_LOGS = process.argv.includes('--json')

async function main(): Promise<void> {
  // TraceStore must be created before any lensFn/lensRoute calls
  const store = createTraceStore(TRACE_DB)
  configureLensFn(store)
  configureLensRoute(store)
  configureLogger(store, JSON_LOGS)

  // HTTP server is non-blocking — returns immediately, event loop handles requests
  startHttpServer()

  // MCP stdio takes over stdin/stdout — must be called after HTTP is started
  // In non-MCP mode (e.g., direct curl testing), omit this call
  if (process.env['LENS_MCP'] !== 'false') {
    await startMcpServer()
  }
}

main().catch((err) => {
  process.stderr.write(`[daemon] fatal: ${String(err)}\n`)
  process.exit(1)
})
```

Note on DATA_DIR: The `~/.lens/` directory must exist before TraceStore opens the DB. Add `mkdirSync(DATA_DIR, { recursive: true })` before `createTraceStore()`:
```typescript
import { mkdirSync } from 'node:fs'
// ...
mkdirSync(DATA_DIR, { recursive: true })
const store = createTraceStore(TRACE_DB)
```

After all files are written:
1. Run `pnpm --filter @lens/daemon build`
2. Run `pnpm --filter @lens/daemon typecheck`
3. Verify with `grep -r 'console.log\|process.stdout.write' apps/daemon/src/` — must return empty
  </action>
  <verify>
    `pnpm --filter @lens/daemon build` exits 0.
    `pnpm --filter @lens/daemon typecheck` exits 0.
    `grep -r 'console\.log\|process\.stdout\.write' apps/daemon/src/` returns empty.
    `LENS_MCP=false node apps/daemon/dist/index.js &amp; sleep 1 &amp;&amp; curl -s http://localhost:4111/health | jq .status` returns `"ok"`.
    Kill the daemon after test: `kill %1`.
  </verify>
  <done>
    Daemon builds and starts on :4111.
    /health returns 200 with status and uptime.
    No stdout writes in daemon src.
    MCP server is registered with lens_grep tool.
  </done>
</task>

</tasks>

<verification>
Full daemon integration test:
```bash
# Start daemon in HTTP-only mode (no MCP stdio takeover)
LENS_MCP=false node apps/daemon/dist/index.js &
sleep 1

# Health check
curl -s http://localhost:4111/health
# Expected: {"status":"ok","uptime":...,"version":"2.0.0"}

# Verify TraceStore received a span (check DB)
sqlite3 ~/.lens/traces.db "SELECT name, duration_ms FROM spans LIMIT 5;"
# Expected: health.get|<number>

kill %1
```
</verification>

<success_criteria>
1. `curl http://localhost:4111/health` returns 200 JSON — daemon is alive
2. Every route handler goes through lensRoute() — confirmed by source grep
3. TraceStore receives spans from HTTP requests — verified via sqlite3 query
4. No stdout writes — verified by grep
5. Single process runs HTTP + MCP on separate I/O channels
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-daemon-mcp/01-02-SUMMARY.md` with:
- Route structure and how to add new routes (lensRoute pattern)
- MCP tool name: `lens_grep` and current stub behavior
- How to start the daemon (with and without MCP mode)
- Data directory location (`~/.lens/`)
- Any deviations from the plan and why
</output>

---
