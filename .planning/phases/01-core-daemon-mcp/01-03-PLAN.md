---
phase: 01-core-daemon-mcp
plan: "03"
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/cli/package.json
  - packages/cli/tsconfig.json
  - packages/cli/tsup.config.ts
  - packages/cli/src/index.ts
autonomous: true
requirements:
  - CLI-01

must_haves:
  truths:
    - "`lens status` prints daemon status to stdout (not stderr) when daemon is running on :4111"
    - "`lens status` exits 0 with a clear error message (not a stack trace) when daemon is not running"
    - "`lens --help` prints usage without crashing"
    - "The `lens` binary is runnable after `pnpm --filter @lens/cli build`"
  artifacts:
    - path: "packages/cli/src/index.ts"
      provides: "citty CLI with status subcommand"
      exports: []
  key_links:
    - from: "packages/cli/src/index.ts"
      to: "http://localhost:4111/health"
      via: "fetch() call in status subcommand"
      pattern: "fetch.*4111|fetch.*health"
---

<objective>
Build the `@lens/cli` skeleton: citty argument parser, `lens status` subcommand that calls the daemon health endpoint and prints output gracefully whether daemon is up or down.

Purpose: Thin CLI shell pattern that Phase 3 fills with `grep`, `register`, `remove`, `list` commands. Establishes the fetch-to-daemon pattern with clean error handling.
Output: `packages/cli/dist/index.js` — executable as `lens` binary.
</objective>

<execution_context>
@/Users/jalipalo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jalipalo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-daemon-mcp/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: CLI scaffold + implementation</name>
  <files>
    packages/cli/package.json
    packages/cli/tsconfig.json
    packages/cli/tsup.config.ts
    packages/cli/src/index.ts
  </files>
  <action>
Update `packages/cli/package.json`:
```json
{
  "name": "@lens/cli",
  "version": "2.0.0",
  "private": true,
  "type": "module",
  "bin": {
    "lens": "./dist/index.js"
  },
  "scripts": {
    "build": "tsup",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "citty": "^0.2.1"
  },
  "devDependencies": {
    "tsup": "^8.5.0",
    "typescript": "^5.7.0"
  }
}
```

Create `packages/cli/tsconfig.json`:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "strict": true,
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src"]
}
```

Create `packages/cli/tsup.config.ts`:
```typescript
import { defineConfig } from 'tsup'

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['esm'],
  dts: false,
  splitting: false,
  clean: true,
  // Add shebang so the binary is directly executable
  banner: {
    js: '#!/usr/bin/env node',
  },
})
```

Create `packages/cli/src/index.ts`:
```typescript
import { defineCommand, runMain } from 'citty'

const DAEMON_URL = 'http://localhost:4111'

const status = defineCommand({
  meta: {
    description: 'Show daemon status. Exits 0 if running, 1 if not reachable.',
  },
  async run() {
    try {
      const res = await fetch(`${DAEMON_URL}/health`)
      if (!res.ok) {
        console.error(`Daemon returned HTTP ${res.status}`)
        process.exit(1)
      }
      const data = (await res.json()) as { status: string; uptime: number; version: string }
      console.log(`lens daemon ${data.version}`)
      console.log(`  status : ${data.status}`)
      console.log(`  uptime : ${data.uptime}s`)
      console.log(`  url    : ${DAEMON_URL}`)
    } catch {
      // fetch throws on connection refused — daemon not running
      console.error('lens daemon is not running. Start it with: lens daemon start')
      process.exit(1)
    }
  },
})

const main = defineCommand({
  meta: {
    name: 'lens',
    version: '2.0.0',
    description: 'LENS — structured code query engine',
  },
  subCommands: {
    status,
  },
})

runMain(main)
```

After writing all files:
1. `pnpm install` from repo root
2. `pnpm --filter @lens/cli build`
3. `pnpm --filter @lens/cli typecheck`
  </action>
  <verify>
    `pnpm --filter @lens/cli build` exits 0.
    `pnpm --filter @lens/cli typecheck` exits 0.
    `node packages/cli/dist/index.js --help` prints usage without crashing.
    `node packages/cli/dist/index.js status` (daemon not running) exits 1 and prints a human-readable error message — no stack trace.
    If daemon is running: `node packages/cli/dist/index.js status` exits 0 and prints version, status, uptime.
  </verify>
  <done>
    `lens` binary builds and runs.
    `lens status` handles daemon-up and daemon-down cases gracefully.
    Zero TS errors.
  </done>
</task>

</tasks>

<verification>
```bash
# Build CLI
pnpm --filter @lens/cli build

# Test with daemon NOT running (expected: exits 1 with message)
node packages/cli/dist/index.js status
echo "Exit code: $?"

# Test --help (expected: exits 0 with usage)
node packages/cli/dist/index.js --help
echo "Exit code: $?"
```
</verification>

<success_criteria>
1. `lens --help` works without crashing
2. `lens status` with daemon down: human-readable error, exit code 1
3. `lens status` with daemon up: prints version, status, uptime
4. No uncaught exceptions — all errors handled
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-daemon-mcp/01-03-SUMMARY.md` with:
- CLI binary path and how to invoke
- Pattern for adding new subcommands (for Phase 3 reference)
- DAEMON_URL constant location
- Any deviations from the plan
</output>

---
