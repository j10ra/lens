---
phase: 01-core-daemon-mcp
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/package.json
  - packages/core/tsconfig.json
  - packages/core/tsup.config.ts
  - packages/core/drizzle.config.ts
  - packages/core/src/index.ts
  - packages/core/src/context.ts
  - packages/core/src/lens-fn.ts
  - packages/core/src/lens-route.ts
  - packages/core/src/logger.ts
  - packages/core/src/trace-store.ts
  - packages/core/src/schema.ts
  - packages/core/drizzle/0000_init.sql
autonomous: true
requirements:
  - CORE-01
  - CORE-02
  - CORE-03
  - CORE-04
  - CORE-05
  - CORE-06

must_haves:
  truths:
    - "A function wrapped in lensFn() records a span (spanId, traceId, name, durationMs, error) in TraceStore without any manual instrumentation"
    - "Nested lensFn() calls produce parent-child span relationships (parentSpanId set correctly)"
    - "Logger.info() inside a lensFn() attaches traceId and spanId to the log row; outside any span it writes without those fields"
    - "Logger writes human-readable text to stderr by default; --json flag switches to one-JSON-object-per-line on stderr"
    - "TraceStore prunes spans older than the retention window automatically on a setInterval schedule"
    - "pnpm --filter @lens/core build produces dist/index.js with named exports: lensFn, lensRoute, Logger, TraceStore"
  artifacts:
    - path: "packages/core/src/context.ts"
      provides: "AsyncLocalStorage store, TraceContext type"
      exports: ["storage", "TraceContext"]
    - path: "packages/core/src/lens-fn.ts"
      provides: "lensFn() wrapper"
      exports: ["lensFn"]
    - path: "packages/core/src/lens-route.ts"
      provides: "lensRoute() wrapper for Hono handlers"
      exports: ["lensRoute"]
    - path: "packages/core/src/logger.ts"
      provides: "Logger class with dual output"
      exports: ["Logger"]
    - path: "packages/core/src/trace-store.ts"
      provides: "TraceStore with Drizzle, WAL, prune"
      exports: ["TraceStore", "createTraceStore"]
    - path: "packages/core/src/schema.ts"
      provides: "Drizzle SQLite schema for traces, spans, logs"
      contains: "sqliteTable"
    - path: "packages/core/drizzle/0000_init.sql"
      provides: "Generated migration SQL"
  key_links:
    - from: "packages/core/src/lens-fn.ts"
      to: "packages/core/src/context.ts"
      via: "storage.run() establishes ALS context"
      pattern: "storage\\.run"
    - from: "packages/core/src/logger.ts"
      to: "packages/core/src/context.ts"
      via: "storage.getStore() reads current traceId/spanId"
      pattern: "storage\\.getStore"
    - from: "packages/core/src/trace-store.ts"
      to: "packages/core/src/schema.ts"
      via: "drizzle(sqlite, { schema })"
      pattern: "drizzle.*schema"
---

<objective>
Build the `@lens/core` package: AsyncLocalStorage context propagation, `lensFn()`, `lensRoute()`, Logger, and TraceStore (Drizzle + better-sqlite3, WAL, batch writes, retention prune).

Purpose: Every function and route in subsequent phases wraps in primitives defined here. API shape is locked after this plan — no retrofitting.
Output: `packages/core/dist/index.js` exporting lensFn, lensRoute, Logger, TraceStore with full TypeScript types.
</objective>

<execution_context>
@/Users/jalipalo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jalipalo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Package scaffold — dependencies, tsconfig, tsup, drizzle config</name>
  <files>
    packages/core/package.json
    packages/core/tsconfig.json
    packages/core/tsup.config.ts
    packages/core/drizzle.config.ts
  </files>
  <action>
Update `packages/core/package.json` to add all runtime and dev dependencies, exports map for dual CJS+ESM, and scripts:

```json
{
  "name": "@lens/core",
  "version": "2.0.0",
  "private": true,
  "type": "module",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    }
  },
  "main": "./dist/index.cjs",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": ["dist", "drizzle"],
  "scripts": {
    "build": "tsup",
    "typecheck": "tsc --noEmit",
    "db:generate": "drizzle-kit generate"
  },
  "dependencies": {
    "drizzle-orm": "^0.45.1",
    "better-sqlite3": "^12.6.2"
  },
  "devDependencies": {
    "@types/better-sqlite3": "^7.6.12",
    "drizzle-kit": "^0.31.9",
    "tsup": "^8.5.0",
    "typescript": "^5.7.0"
  }
}
```

Create `packages/core/tsconfig.json`:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "strict": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src"]
}
```

Create `packages/core/tsup.config.ts`:
```typescript
import { defineConfig } from 'tsup'

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['esm', 'cjs'],
  dts: true,
  splitting: false,
  clean: true,
  banner(ctx) {
    // better-sqlite3 is a native CJS addon — needs createRequire in ESM context
    if (ctx.format === 'esm') {
      return {
        js: `import {createRequire as __createRequire} from 'module';var require=__createRequire(import.meta.url);`
      }
    }
    return {}
  },
})
```

Create `packages/core/drizzle.config.ts`:
```typescript
import { defineConfig } from 'drizzle-kit'

export default defineConfig({
  dialect: 'sqlite',
  schema: './src/schema.ts',
  out: './drizzle',
  dbCredentials: { url: './traces.db' },
})
```

Run `pnpm install` from repo root to install new deps.
  </action>
  <verify>
    `pnpm --filter @lens/core install` exits 0.
    `cat packages/core/package.json` shows `drizzle-orm` and `better-sqlite3` in dependencies.
    `packages/core/tsup.config.ts` exists with format-conditional banner.
  </verify>
  <done>All four config files exist and deps are installed.</done>
</task>

<task type="auto">
  <name>Task 2: Core implementation — context, lensFn, lensRoute, Logger, TraceStore, schema</name>
  <files>
    packages/core/src/context.ts
    packages/core/src/schema.ts
    packages/core/src/trace-store.ts
    packages/core/src/lens-fn.ts
    packages/core/src/lens-route.ts
    packages/core/src/logger.ts
    packages/core/src/index.ts
  </files>
  <action>
Create each file in this order (schema → trace-store → context → lens-fn → lens-route → logger → index):

**`packages/core/src/schema.ts`** — Drizzle SQLite schema (flat spans with parentSpanId, OpenTelemetry model):
```typescript
import { integer, real, sqliteTable, text } from 'drizzle-orm/sqlite-core'

export const traces = sqliteTable('traces', {
  traceId: text('trace_id').primaryKey(),
  rootSpanName: text('root_span_name').notNull(),
  startedAt: integer('started_at').notNull(),  // Unix ms
  endedAt: integer('ended_at'),
  durationMs: real('duration_ms'),
})

export const spans = sqliteTable('spans', {
  spanId: text('span_id').primaryKey(),
  traceId: text('trace_id').notNull().references(() => traces.traceId, { onDelete: 'cascade' }),
  parentSpanId: text('parent_span_id'),
  name: text('name').notNull(),
  startedAt: integer('started_at').notNull(),
  durationMs: real('duration_ms'),
  errorMessage: text('error_message'),
  inputSize: integer('input_size'),
  outputSize: integer('output_size'),
})

export const logs = sqliteTable('logs', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  traceId: text('trace_id'),
  spanId: text('span_id'),
  level: text('level', { enum: ['info', 'warn', 'error', 'debug'] }).notNull(),
  message: text('message').notNull(),
  timestamp: integer('timestamp').notNull(),
})
```

**`packages/core/src/context.ts`** — AsyncLocalStorage store and types:
```typescript
import { AsyncLocalStorage } from 'node:async_hooks'

export interface Span {
  spanId: string
  parentSpanId: string | undefined
  name: string
  startMs: number
}

export interface TraceContext {
  traceId: string
  spanStack: Span[]
}

export const storage = new AsyncLocalStorage<TraceContext>()

/** Returns the deepest active span, or undefined if outside any lensFn/lensRoute context. */
export function currentSpan(): Span | undefined {
  const store = storage.getStore()
  return store?.spanStack.at(-1)
}
```

**`packages/core/src/trace-store.ts`** — Drizzle DB, WAL, batch flush, retention prune:
```typescript
import Database from 'better-sqlite3'
import { drizzle } from 'drizzle-orm/better-sqlite3'
import { migrate } from 'drizzle-orm/better-sqlite3/migrator'
import { lt } from 'drizzle-orm'
import * as schema from './schema.js'
import { fileURLToPath } from 'node:url'
import { join, dirname } from 'node:path'

const __dirname = dirname(fileURLToPath(import.meta.url))

export interface SpanRecord {
  spanId: string
  traceId: string
  parentSpanId: string | undefined
  name: string
  startedAt: number
  durationMs: number
  errorMessage?: string
  inputSize?: number
  outputSize?: number
}

export interface LogRecord {
  traceId?: string
  spanId?: string
  level: 'info' | 'warn' | 'error' | 'debug'
  message: string
  timestamp: number
}

export class TraceStore {
  private db: ReturnType<typeof drizzle<typeof schema>>
  private sqlite: Database.Database
  private spanBuffer: SpanRecord[] = []
  private logBuffer: LogRecord[] = []
  private flushTimer: ReturnType<typeof setInterval>
  private pruneTimer: ReturnType<typeof setInterval>
  readonly retentionMs: number

  constructor(dbPath: string, retentionMs = 7 * 24 * 60 * 60 * 1000) {
    this.sqlite = new Database(dbPath)
    // WAL mode before anything else — critical for concurrent read performance
    this.sqlite.pragma('journal_mode = WAL')
    this.sqlite.pragma('synchronous = NORMAL')
    this.sqlite.pragma('foreign_keys = ON')

    this.db = drizzle(this.sqlite, { schema })

    // Migrations folder is co-located with the built package
    const migrationsFolder = join(__dirname, '..', 'drizzle')
    migrate(this.db, { migrationsFolder })

    this.retentionMs = retentionMs

    // Batch flush every 100ms — time-based batching, minimal complexity
    this.flushTimer = setInterval(() => this.flush(), 100)
    // Prune old traces hourly
    this.pruneTimer = setInterval(() => this.prune(), 60 * 60 * 1000)
  }

  pushSpan(span: SpanRecord): void {
    this.spanBuffer.push(span)
  }

  pushLog(log: LogRecord): void {
    this.logBuffer.push(log)
  }

  private flush(): void {
    if (this.spanBuffer.length === 0 && this.logBuffer.length === 0) return

    const spans = this.spanBuffer.splice(0)
    const logs = this.logBuffer.splice(0)

    // Group spans by trace; upsert traces first (foreign key constraint)
    const traceMap = new Map<string, { name: string; startedAt: number; endedAt: number; durationMs: number }>()
    for (const s of spans) {
      const existing = traceMap.get(s.traceId)
      if (!existing || s.startedAt < existing.startedAt) {
        traceMap.set(s.traceId, {
          name: s.parentSpanId == null ? s.name : existing?.name ?? s.name,
          startedAt: Math.min(s.startedAt, existing?.startedAt ?? s.startedAt),
          endedAt: Math.max(s.startedAt + s.durationMs, existing?.endedAt ?? 0),
          durationMs: s.durationMs,
        })
      }
    }

    this.sqlite.transaction(() => {
      for (const [traceId, t] of traceMap) {
        this.sqlite.prepare(
          `INSERT INTO traces (trace_id, root_span_name, started_at, ended_at, duration_ms)
           VALUES (?, ?, ?, ?, ?)
           ON CONFLICT(trace_id) DO UPDATE SET ended_at = excluded.ended_at, duration_ms = excluded.duration_ms`
        ).run(traceId, t.name, t.startedAt, t.endedAt, t.durationMs)
      }

      for (const s of spans) {
        this.sqlite.prepare(
          `INSERT OR IGNORE INTO spans (span_id, trace_id, parent_span_id, name, started_at, duration_ms, error_message, input_size, output_size)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`
        ).run(s.spanId, s.traceId, s.parentSpanId ?? null, s.name, s.startedAt, s.durationMs, s.errorMessage ?? null, s.inputSize ?? null, s.outputSize ?? null)
      }

      for (const l of logs) {
        this.sqlite.prepare(
          `INSERT INTO logs (trace_id, span_id, level, message, timestamp) VALUES (?, ?, ?, ?, ?)`
        ).run(l.traceId ?? null, l.spanId ?? null, l.level, l.message, l.timestamp)
      }
    })()
  }

  prune(): void {
    const cutoff = Date.now() - this.retentionMs
    // Cascade delete handles spans and logs via foreign key (or manual if needed)
    this.sqlite.prepare(`DELETE FROM traces WHERE started_at < ?`).run(cutoff)
    // Orphaned logs (no trace_id) older than retention
    this.sqlite.prepare(`DELETE FROM logs WHERE trace_id IS NULL AND timestamp < ?`).run(cutoff)
  }

  close(): void {
    clearInterval(this.flushTimer)
    clearInterval(this.pruneTimer)
    this.flush()
    this.sqlite.close()
  }
}

/** Factory — creates and returns a singleton-friendly TraceStore instance. */
export function createTraceStore(dbPath: string, retentionMs?: number): TraceStore {
  return new TraceStore(dbPath, retentionMs)
}
```

**`packages/core/src/lens-fn.ts`** — lensFn() with ALS context propagation:
```typescript
import { crypto } from 'node:crypto'  // Node 19+ — use randomUUID from crypto module
import { storage, type Span, type TraceContext } from './context.js'
import type { TraceStore } from './trace-store.js'

// Global TraceStore reference — set via configure() before first lensFn call
let _store: TraceStore | undefined

export function configureLensFn(store: TraceStore): void {
  _store = store
}

export function lensFn<TArgs extends unknown[], TReturn>(
  name: string,
  fn: (...args: TArgs) => Promise<TReturn>
): (...args: TArgs) => Promise<TReturn> {
  return async (...args: TArgs): Promise<TReturn> => {
    const parent = storage.getStore()
    const spanId = crypto.randomUUID()
    const traceId = parent?.traceId ?? crypto.randomUUID()

    const parentSpanId = parent?.spanStack.at(-1)?.spanId
    const span: Span = { spanId, parentSpanId, name, startMs: Date.now() }

    const ctx: TraceContext = {
      traceId,
      spanStack: parent ? [...parent.spanStack, span] : [span],
    }

    const startMs = Date.now()

    return storage.run(ctx, async () => {
      let errorMessage: string | undefined
      try {
        const result = await fn(...args)
        const inputSize = estimateSize(args)
        const outputSize = estimateSize(result)
        _store?.pushSpan({
          spanId,
          traceId,
          parentSpanId,
          name,
          startedAt: startMs,
          durationMs: Date.now() - startMs,
          inputSize,
          outputSize,
        })
        return result
      } catch (err) {
        errorMessage = err instanceof Error ? err.message : String(err)
        _store?.pushSpan({
          spanId,
          traceId,
          parentSpanId,
          name,
          startedAt: startMs,
          durationMs: Date.now() - startMs,
          errorMessage,
        })
        throw err
      }
    })
  }
}

function estimateSize(value: unknown): number {
  try {
    return JSON.stringify(value)?.length ?? 0
  } catch {
    return 0
  }
}
```

Note: Use `import { randomUUID } from 'node:crypto'` (not `crypto.randomUUID()` — that's the Web Crypto API). Correct import:
```typescript
import { randomUUID } from 'node:crypto'
// then use: randomUUID()
```

**`packages/core/src/lens-route.ts`** — lensRoute() wraps Hono handlers:
```typescript
import { randomUUID } from 'node:crypto'
import type { Context, Handler, Env, Input } from 'hono'
import { storage, type TraceContext, type Span } from './context.js'
import type { TraceStore } from './trace-store.js'

let _store: TraceStore | undefined

export function configureLensRoute(store: TraceStore): void {
  _store = store
}

export function lensRoute<E extends Env = Env, P extends string = string, I extends Input = Input>(
  name: string,
  handler: Handler<E, P, I>
): Handler<E, P, I> {
  return async (c: Context<E, P, I>, next) => {
    const spanId = randomUUID()
    const traceId = randomUUID()
    const startMs = Date.now()

    const span: Span = { spanId, parentSpanId: undefined, name, startMs }
    const ctx: TraceContext = { traceId, spanStack: [span] }

    return storage.run(ctx, async () => {
      let status = 200
      try {
        await handler(c, next)
        status = c.res.status
      } catch (err) {
        _store?.pushSpan({
          spanId,
          traceId,
          parentSpanId: undefined,
          name,
          startedAt: startMs,
          durationMs: Date.now() - startMs,
          errorMessage: err instanceof Error ? err.message : String(err),
        })
        throw err
      }
      _store?.pushSpan({
        spanId,
        traceId,
        parentSpanId: undefined,
        name,
        startedAt: startMs,
        durationMs: Date.now() - startMs,
        inputSize: Number(c.req.header('content-length') ?? 0),
      })
    })
  }
}
```

**`packages/core/src/logger.ts`** — Logger with dual output (stderr + TraceStore):
```typescript
import { storage } from './context.js'
import type { TraceStore } from './trace-store.js'

type LogLevel = 'info' | 'warn' | 'error' | 'debug'

let _store: TraceStore | undefined
let _jsonMode = false

export function configureLogger(store: TraceStore, jsonMode = false): void {
  _store = store
  _jsonMode = jsonMode
}

export const Logger = {
  info: (message: string) => log('info', message),
  warn: (message: string) => log('warn', message),
  error: (message: string) => log('error', message),
  debug: (message: string) => log('debug', message),
}

function log(level: LogLevel, message: string): void {
  const store = storage.getStore()
  const traceId = store?.traceId
  const spanId = store?.spanStack.at(-1)?.spanId
  const timestamp = Date.now()

  // Persist to TraceStore (async-safe: pushLog is synchronous buffer push)
  _store?.pushLog({ traceId, spanId, level, message, timestamp })

  // Write to stderr — NEVER stdout (MCP stdio uses stdout for JSON-RPC)
  const entry = _jsonMode
    ? JSON.stringify({ timestamp, level, message, traceId, spanId }) + '\n'
    : formatHuman(level, message, traceId, spanId)

  process.stderr.write(entry)
}

const LEVEL_LABELS: Record<LogLevel, string> = {
  info: 'INF',
  warn: 'WRN',
  error: 'ERR',
  debug: 'DBG',
}

function formatHuman(level: LogLevel, message: string, traceId?: string, spanId?: string): string {
  const ts = new Date().toISOString().slice(11, 23)  // HH:MM:SS.mmm
  const label = LEVEL_LABELS[level]
  const trace = traceId ? ` [${traceId.slice(0, 8)}]` : ''
  return `${ts} ${label}${trace} ${message}\n`
}
```

**`packages/core/src/index.ts`** — barrel export:
```typescript
export { lensFn, configureLensFn } from './lens-fn.js'
export { lensRoute, configureLensRoute } from './lens-route.js'
export { Logger, configureLogger } from './logger.js'
export { TraceStore, createTraceStore } from './trace-store.js'
export { storage, currentSpan } from './context.js'
export type { TraceContext, Span } from './context.js'
export type { SpanRecord, LogRecord } from './trace-store.js'
```

After writing all files, run `pnpm --filter @lens/core run db:generate` to produce the Drizzle migration SQL in `packages/core/drizzle/`.

Then run `pnpm --filter @lens/core build` to compile.

Finally run `pnpm --filter @lens/core typecheck` to confirm zero TS errors.
  </action>
  <verify>
    `pnpm --filter @lens/core build` exits 0 with no errors.
    `pnpm --filter @lens/core typecheck` exits 0.
    `ls packages/core/dist/` shows `index.js`, `index.cjs`, `index.d.ts`.
    `ls packages/core/drizzle/` shows at least one `.sql` migration file.
    `grep -r 'console.log' packages/core/src/` returns empty (no stdout writes).
  </verify>
  <done>
    `packages/core/dist/index.js` exports lensFn, lensRoute, Logger, TraceStore.
    Migration SQL exists in `packages/core/drizzle/`.
    Zero TypeScript errors.
    No `console.log` in src/.
  </done>
</task>

</tasks>

<verification>
Manual smoke test after build:

```typescript
// test-smoke.mts — run with: node --input-type=module < test-smoke.mts
import { lensFn, createTraceStore, configureLensFn, Logger, configureLogger } from './packages/core/dist/index.js'

const store = createTraceStore('/tmp/lens-test.db')
configureLensFn(store)
configureLogger(store)

const greet = lensFn('greet', async (name: string) => `hello ${name}`)
const result = await greet('world')
Logger.info('smoke test passed')
console.assert(result === 'hello world', 'greet returned wrong value')

store.close()
process.exit(0)
```

Expected: stderr shows `INF smoke test passed`, process exits 0, `/tmp/lens-test.db` contains rows in `spans` table.
</verification>

<success_criteria>
1. lensFn() wraps async functions with zero-config tracing — no manual span creation needed
2. Nested lensFn() calls produce correct parentSpanId chains in the database
3. Logger writes to stderr exclusively (verified by grep)
4. TraceStore uses WAL mode, batches writes at 100ms intervals, and prunes on schedule
5. `pnpm --filter @lens/core build` exits 0 producing ESM+CJS dual output
6. Zero TypeScript errors via `tsc --noEmit`
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-daemon-mcp/01-01-SUMMARY.md` with:
- Key exports and their signatures
- TraceStore schema summary (table names, key columns)
- The configure*() pattern (how to wire store into lensFn/lensRoute/Logger)
- Any deviations from the plan and why
- Build output paths
</output>

