---
phase: 02-intelligence-engine
plan: "04"
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - packages/engine/src/grep/grep.ts
  - packages/engine/src/index.ts
autonomous: true
requirements: [ENGN-07, ENGN-08]

must_haves:
  truths:
    - "grepRepo() returns per-term results enriched with importers, cochangePartners, isHub, hubScore, exports, docstring"
    - "Every exported function in packages/engine/src/index.ts is wrapped in lensFn()"
    - "grep for '^export (async )?function' in packages/engine/src/ returns 0 matches (no naked function exports)"
    - "grepRepo() splits pipe-separated query into terms and scores each independently"
  artifacts:
    - path: "packages/engine/src/grep/grep.ts"
      provides: "grepRepo() — top-level structural grep"
      exports: ["grepRepo"]
    - path: "packages/engine/src/index.ts"
      provides: "Public barrel — all engine exports wrapped in lensFn()"
      exports: ["runIndex", "registerRepo", "removeRepo", "listRepos", "getRepoStatus", "grepRepo", "configureEngineDb", "getEngineDb"]
  key_links:
    - from: "packages/engine/src/grep/grep.ts"
      to: "packages/engine/src/grep/scorer.ts"
      via: "interpretQuery() call"
      pattern: "interpretQuery"
    - from: "packages/engine/src/grep/grep.ts"
      to: "packages/engine/src/grep/structural.ts"
      via: "getReverseImports() + getCochangePartners() for enrichment"
      pattern: "getReverseImports|getCochangePartners"
    - from: "packages/engine/src/index.ts"
      to: "packages/engine/src/grep/grep.ts"
      via: "re-export grepRepo"
      pattern: "grepRepo"
---

<objective>
Grep engine and public barrel exports — the query interface and the ENGN-08 compliance gate.

Purpose: `grepRepo()` is the top-level grep function that scores files, enriches results with structural metadata (importers, co-change partners, hub status), and returns the complete response shape. The barrel `index.ts` wraps all engine exports in `lensFn()` ensuring ENGN-08 compliance (no naked exports).
Output: `grep.ts` (query entry point), `index.ts` (barrel with lensFn-wrapped exports).
</objective>

<execution_context>
@/Users/jalipalo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jalipalo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-intelligence-engine/02-RESEARCH.md
@.planning/phases/02-intelligence-engine/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: grepRepo() — structural grep with result enrichment</name>
  <files>
    packages/engine/src/grep/grep.ts
  </files>
  <action>
**grep.ts** — Top-level grep function. This IS exported and will be wrapped in lensFn via the barrel.

- `grepRepo(db: Db, repoId: string, query: string, limit: number = 20): GrepResult` — Synchronous (all DB ops are sync via better-sqlite3, but the barrel wraps it as async via lensFn).

  Algorithm:
  1. Split query on `|` pipe, trim, filter empty → `terms: string[]`.
  2. Call `interpretQuery(db, repoId, terms, limit)` → `ScoredFile[]` (already ranked by composite score).
  3. **Enrich each scored file** with structural metadata:
     - `importers`: `getReverseImports(db, repoId, file.path)` — files that import this file.
     - `cochangePartners`: `getCochangePartners(db, repoId, file.path, 5)` — top 5 co-change partners with counts.
     - `exports`: Parse from fileMetadata (already loaded during scoring, pass through).
     - `docstring`: Parse from fileMetadata.
     - `isHub`, `hubScore`: Already computed by scorer.
  4. Group results by term: for each term, filter scored files to those where `matchedTerms.includes(term)`.
  5. Return `GrepResult`:
     ```typescript
     type GrepResult = {
       repoId: string;
       terms: string[];
       results: Record<string, EnrichedMatch[]>;
     };
     type EnrichedMatch = {
       path: string;
       score: number;
       language: string | null;
       importers: string[];
       cochangePartners: Array<{ path: string; count: number }>;
       isHub: boolean;
       hubScore: number;
       exports: string[];
       docstring: string;
     };
     ```

  The result shape matches the v2 grep output format from the research (Pattern 6). Files may appear under multiple terms if they match multiple query terms.

  To get metadata for enrichment: `metadataQueries.getByRepoPath(db, repoId, file.path)` — parse exports and docstring from the metadata row.
  </action>
  <verify>
    `pnpm --filter @lens/engine build` succeeds.
    `pnpm --filter @lens/engine typecheck` exits 0.
    `grep -r "importers\|cochangePartners\|isHub\|hubScore" packages/engine/src/grep/grep.ts` confirms enrichment fields.
    `grep -r "interpretQuery" packages/engine/src/grep/grep.ts` confirms scorer integration.
  </verify>
  <done>
    grepRepo() splits pipe-separated query into terms, scores via interpretQuery(), enriches each result with importers, co-change partners, hub status, exports, and docstring (ENGN-07). Results grouped by term with shared files appearing under multiple terms.
  </done>
</task>

<task type="auto">
  <name>Task 2: Public barrel exports with lensFn wrapping + ENGN-08 verification</name>
  <files>
    packages/engine/src/index.ts
  </files>
  <action>
**index.ts** — The public API surface. Every export MUST be wrapped in `lensFn()`.

Structure:
```typescript
import { lensFn } from "@lens/core";
// Import raw implementations
import { configureEngineDb, getEngineDb } from "./db/connection.js";
import type { Db } from "./db/connection.js";
import { grepRepoImpl } from "./grep/grep.js";
import { runIndexImpl } from "./index/engine.js";
import { registerRepoImpl, removeRepoImpl, listReposImpl, getRepoStatusImpl } from "./repo/repo.js";

// Re-export DB setup (not lensFn-wrapped — configure/get are infra, not engine operations)
export { configureEngineDb, getEngineDb } from "./db/connection.js";
export type { Db } from "./db/connection.js";

// lensFn-wrapped exports — all engine operations get traced
export const runIndex = lensFn("engine.runIndex", runIndexImpl);
export const registerRepo = lensFn("engine.registerRepo", registerRepoImpl);
export const removeRepo = lensFn("engine.removeRepo", removeRepoImpl);
export const listRepos = lensFn("engine.listRepos", listReposImpl);
export const getRepoStatus = lensFn("engine.getRepoStatus", getRepoStatusImpl);
export const grepRepo = lensFn("engine.grepRepo", grepRepoImpl);
```

**IMPORTANT:** The source modules (grep.ts, engine.ts, repo.ts) must export their raw implementations with an `Impl` suffix or a different name so the barrel can wrap them. Two approaches:
- Option A: Source files export named `xxxImpl` functions, barrel wraps with `lensFn()` and re-exports as `xxx`.
- Option B: Source files export normally, barrel imports with `as` alias and wraps.

Choose Option A (cleaner — makes it explicit which functions are raw vs wrapped).

For `runIndex`: it's already async (uses readFile, execFile for git). lensFn wraps async correctly.
For `registerRepo`: async (calls getHeadCommit). lensFn wraps async correctly.
For `removeRepo`, `listRepos`, `getRepoStatus`: sync DB calls. Convert to async wrappers (return Promise) so lensFn can wrap them. Simplest: make them `async function removeRepoImpl(...)` even though the body is sync — the overhead is negligible and lensFn requires async.
For `grepRepo`: sync DB calls. Same — make async for lensFn compatibility.

**ENGN-08 verification command** (must be run and pass):
```bash
grep -rE "^export (async )?function" packages/engine/src/
```
This MUST return 0 matches. All exports go through the barrel via `export const xxx = lensFn(...)`.

Internal helper exports within submodules (e.g., `export function extractImportSpecifiers` in imports.ts) are fine — they are NOT in the public barrel (`index.ts`). Only `index.ts` exports are the public API. But to be safe, submodule exports should use `export function` only for module-internal consumption (imported by sibling files). The grep above should be restricted to `packages/engine/src/index.ts` or the grep should verify that `index.ts` has no `export function` patterns.

Refined verification: `grep -E "^export (async )?function" packages/engine/src/index.ts` must return 0 matches.

Also re-export types needed by consumers:
```typescript
export type { GrepResult, EnrichedMatch } from "./grep/grep.js";
export type { IndexResult } from "./index/engine.js";
```
  </action>
  <verify>
    `pnpm --filter @lens/engine build` succeeds.
    `pnpm --filter @lens/engine typecheck` exits 0.
    `grep -E "^export (async )?function" packages/engine/src/index.ts` returns 0 matches (ENGN-08).
    `grep -c "lensFn" packages/engine/src/index.ts` returns >= 5 (one per wrapped export).
    `grep -r "export const.*lensFn" packages/engine/src/index.ts` confirms pattern.
  </verify>
  <done>
    All engine exports wrapped in lensFn() (ENGN-08). Public barrel exports: runIndex, registerRepo, removeRepo, listRepos, getRepoStatus, grepRepo, configureEngineDb, getEngineDb. Type exports: Db, GrepResult, EnrichedMatch, IndexResult. No naked exported functions in index.ts.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @lens/engine build` exits 0
- `pnpm --filter @lens/engine typecheck` exits 0
- `grep -E "^export (async )?function" packages/engine/src/index.ts` returns 0 matches
- `grep -c "lensFn" packages/engine/src/index.ts` returns >= 5
- `grep -r "importers\|cochangePartners\|isHub" packages/engine/src/grep/grep.ts` shows enrichment
</verification>

<success_criteria>
- grepRepo() returns per-term results enriched with structural metadata (ENGN-07)
- Every public export wrapped in lensFn() (ENGN-08)
- Engine package builds and typechecks
- GrepResult type matches the v2 output shape from research
</success_criteria>

<output>
After completion, create `.planning/phases/02-intelligence-engine/02-04-SUMMARY.md`
</output>
