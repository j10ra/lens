---
phase: 02-intelligence-engine
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/engine/package.json
  - packages/engine/tsconfig.json
  - packages/engine/tsup.config.ts
  - packages/engine/src/db/connection.ts
  - packages/engine/src/db/schema.ts
  - packages/engine/src/db/queries.ts
  - packages/engine/src/index/discovery.ts
  - packages/engine/src/index/chunker.ts
  - packages/engine/src/index/extract-metadata.ts
  - packages/engine/src/repo/identity.ts
  - packages/engine/src/repo/repo.ts
autonomous: true
requirements: [ENGN-01, DAEM-05]

must_haves:
  truths:
    - "Engine DB opens at ~/.lens/index.db with WAL mode, busy_timeout, foreign_keys"
    - "fullScan() returns a list of files respecting .gitignore via git ls-files"
    - "chunkFile() splits file content into overlapping 150-line windows with SHA-256 hashes"
    - "extractFileMetadata() extracts exports, imports, docstring, sections, internals from file content"
    - "registerRepo() creates a repo row with identity_key derived from remote URL or root path"
    - "listRepos() returns all registered repos; removeRepo() deletes repo and cascades"
  artifacts:
    - path: "packages/engine/src/db/connection.ts"
      provides: "configureEngineDb(), getEngineDb(), Db type"
      exports: ["configureEngineDb", "getEngineDb"]
    - path: "packages/engine/src/db/schema.ts"
      provides: "6 Drizzle tables: repos, chunks, fileMetadata, fileImports, fileStats, fileCochanges"
      contains: "sqliteTable"
    - path: "packages/engine/src/db/queries.ts"
      provides: "Typed query helpers grouped by table"
      exports: ["repoQueries", "chunkQueries", "metadataQueries"]
    - path: "packages/engine/src/index/discovery.ts"
      provides: "fullScan(), diffScan(), getHeadCommit()"
    - path: "packages/engine/src/index/chunker.ts"
      provides: "chunkFile() — boundary-aware splitting"
    - path: "packages/engine/src/index/extract-metadata.ts"
      provides: "extractFileMetadata(), extractAndPersistMetadata()"
    - path: "packages/engine/src/repo/identity.ts"
      provides: "deriveIdentityKey()"
    - path: "packages/engine/src/repo/repo.ts"
      provides: "registerRepo(), removeRepo(), listRepos()"
  key_links:
    - from: "packages/engine/src/db/connection.ts"
      to: "packages/engine/src/db/schema.ts"
      via: "drizzle(sqlite, { schema })"
      pattern: "import.*schema"
    - from: "packages/engine/src/repo/repo.ts"
      to: "packages/engine/src/db/queries.ts"
      via: "repoQueries.insert/delete/getAll"
      pattern: "repoQueries"
---

<objective>
Engine DB schema, file discovery, chunking, metadata extraction, and repo management — the foundation that all subsequent engine plans build on.

Purpose: Establishes the engine's data layer (Drizzle schema + SQLite connection), file scanning pipeline (git ls-files), content chunking, and metadata extraction. Also provides repo registration/removal which is the entry point for all engine operations.
Output: `packages/engine/` fully scaffolded with db/, index/, and repo/ modules. A repo can be registered, files discovered, content chunked, and metadata extracted.
</objective>

<execution_context>
@/Users/jalipalo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jalipalo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-intelligence-engine/02-RESEARCH.md
@.planning/phases/01-core-daemon-mcp/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Engine package scaffold + DB layer</name>
  <files>
    packages/engine/package.json
    packages/engine/tsconfig.json
    packages/engine/tsup.config.ts
    packages/engine/src/db/connection.ts
    packages/engine/src/db/schema.ts
    packages/engine/src/db/queries.ts
  </files>
  <action>
**package.json** — Add dependencies: `better-sqlite3`, `drizzle-orm`. Add devDependencies: `@types/better-sqlite3`, `@types/node`, `drizzle-kit`, `tsup`, `typescript`. Keep `@lens/core` as workspace dependency. Add `"types"` field pointing to `"./dist/index.d.ts"`.

**tsconfig.json** — Extend from root or create standalone. Target ES2022, module NodeNext, moduleResolution NodeNext, strict true, skipLibCheck true (drizzle-orm 0.45.1 broken .d.ts), outDir dist, rootDir src. Include `["src"]`.

**tsup.config.ts** — ESM-only format (like daemon). Entry `src/index.ts`. External `@lens/core`. Clean output. DTS generation enabled.

**connection.ts** — Singleton pattern matching Phase 1's configure*() approach:
- `configureEngineDb(dbPath: string): Db` — creates better-sqlite3 Database, sets `pragma journal_mode=WAL`, `pragma busy_timeout=5000`, `pragma foreign_keys=ON`, runs inline `CREATE TABLE IF NOT EXISTS` SQL for all 6 tables (not drizzle-kit migrations — see research: "inline SQL is simpler than migration files"), wraps with `drizzle(sqlite, { schema })`, stores in module-level `_db`.
- `getEngineDb(): Db` — returns `_db` or throws if not initialized.
- Export `type Db = BetterSQLite3Database<typeof schema>`.
- The `CREATE TABLE IF NOT EXISTS` SQL must match the Drizzle schema exactly (columns, types, indexes, foreign keys with CASCADE).

**schema.ts** — 6 Drizzle tables exactly as specified in research:
- `repos` — id, identity_key (unique), name, root_path, remote_url, last_indexed_commit, index_status (default "pending"), last_indexed_at, last_git_analysis_commit, max_import_depth (default 0), created_at
- `chunks` — id, repo_id (FK→repos CASCADE), path, chunk_index, start_line, end_line, content, chunk_hash, last_seen_commit, language. Indexes: unique on (repo_id, path, chunk_index, chunk_hash), composite on (repo_id, path).
- `fileMetadata` — id, repo_id (FK→repos CASCADE), path, language, exports (JSON text default "[]"), imports (JSON text default "[]"), docstring (text default ""), sections (JSON text default "[]"), internals (JSON text default "[]"). Unique index on (repo_id, path).
- `fileImports` — id, repo_id (FK→repos CASCADE), source_path, target_path. Unique index on (repo_id, source_path, target_path). Indexes on target and source.
- `fileStats` — id, repo_id (FK→repos CASCADE), path, commit_count (default 0), recent_count (default 0), last_modified. Unique index on (repo_id, path).
- `fileCochanges` — id, repo_id (FK→repos CASCADE), path_a, path_b, cochange_count (default 1). Unique index on (repo_id, path_a, path_b). Index on (repo_id, path_a).

Use helper functions: `uuid()` for text PK with `crypto.randomUUID()`, `now()` for created_at default `datetime('now')`.

**queries.ts** — Grouped query objects:
- `repoQueries`: `insert(db, data)`, `getById(db, id)`, `getByIdentityKey(db, key)`, `getAll(db)`, `remove(db, id)`, `setIndexing(db, id)`, `updateIndexState(db, id, commit, status)`.
- `chunkQueries`: `upsertChunks(db, repoId, path, chunks[])`, `getByRepoPath(db, repoId, path)`, `deleteByRepo(db, repoId)`, `getAllPaths(db, repoId)`.
- `metadataQueries`: `upsert(db, repoId, path, metadata)`, `getByRepoPath(db, repoId, path)`, `getAllForRepo(db, repoId)`.
- `importQueries`: `insertEdges(db, repoId, edges[])`, `clearForRepo(db, repoId)`, `getImporters(db, repoId, targetPath)`, `getImports(db, repoId, sourcePath)`.
- `statsQueries`: `upsertStats(db, repoId, stats[])`, `getByPath(db, repoId, path)`.
- `cochangeQueries`: `upsertPairs(db, repoId, pairs[])`, `getPartners(db, repoId, path)`, `clearForRepo(db, repoId)`.

All write operations that touch multiple rows should use `db.transaction()` for atomicity.
  </action>
  <verify>
    `pnpm install` succeeds.
    `pnpm --filter @lens/engine build` compiles without error.
    `pnpm --filter @lens/engine typecheck` exits 0.
    Inspect dist/index.js exists (even if barrel is minimal at this point).
  </verify>
  <done>
    Engine package builds. DB connection opens with WAL+busy_timeout+foreign_keys. All 6 schema tables defined. Query helpers cover all CRUD patterns needed by subsequent plans.
  </done>
</task>

<task type="auto">
  <name>Task 2: File discovery, chunker, metadata extraction, repo management</name>
  <files>
    packages/engine/src/index/discovery.ts
    packages/engine/src/index/chunker.ts
    packages/engine/src/index/extract-metadata.ts
    packages/engine/src/repo/identity.ts
    packages/engine/src/repo/repo.ts
  </files>
  <action>
**discovery.ts** — Port from v1 (`git show v1-archive:packages/engine/src/index/discovery.ts` for reference):
- `fullScan(repoRoot: string): Promise<DiscoveredFile[]>` — runs `execFile("git", ["ls-files", "-z"], { cwd: repoRoot, maxBuffer: 50*1024*1024 })`. Split on `\0`, filter empty. For each path: detect language from extension (map: `.ts`→typescript, `.tsx`→typescriptreact, `.js`→javascript, `.jsx`→javascriptreact, `.py`→python, `.go`→go, `.rs`→rust, `.json`→json, `.md`→markdown, `.css`→css, `.html`→html). Filter out binary extensions (`.png`, `.jpg`, `.gif`, `.ico`, `.woff`, `.woff2`, `.ttf`, `.eot`, `.mp3`, `.mp4`, `.zip`, `.tar`, `.gz`, `.pdf`, `.lock`). Skip files >2MB via `stat()`.
- `diffScan(repoRoot, fromCommit, toCommit): Promise<DiscoveredFile[]>` — `git diff --name-status --diff-filter=ACMRD -z` between commits. Parse status+path pairs.
- `getHeadCommit(repoRoot: string): Promise<string>` — `git rev-parse HEAD`.
- `DiscoveredFile = { path: string, language: string | null }`.
- Use `node:child_process` `execFile` promisified via `util.promisify`.

**chunker.ts** — Port from v1 (`git show v1-archive:packages/engine/src/index/chunker.ts`):
- `chunkFile(content: string, path: string, options?): Chunk[]` — Synchronous. Split content into lines. Create chunks of `CHUNK_SIZE=150` lines with `OVERLAP=20` lines. Each chunk gets: `chunkIndex` (0-based), `startLine`, `endLine`, `content` (joined lines), `chunkHash` (SHA-256 of content via `node:crypto createHash`). Try to split on blank lines near boundaries for cleaner chunks.
- `Chunk = { chunkIndex: number, startLine: number, endLine: number, content: string, chunkHash: string }`.
- This is a synchronous internal helper — do NOT wrap in lensFn().

**extract-metadata.ts** — Port from v1 (`git show v1-archive:packages/engine/src/index/extract-metadata.ts`):
- `extractFileMetadata(content: string, path: string, language: string | null): FileMetadata` — Synchronous. Extracts:
  - `exports`: regex for `export (const|function|class|type|interface|enum|default)` → capture names. Also handle `export { name }` re-exports.
  - `imports`: regex for `import .* from ['"](.+)['"]` and `require\(['"](.+)['"]\)` → capture specifiers.
  - `docstring`: first `/** ... */` block or `# ...` comment block at file top (first 20 lines).
  - `sections`: function/class/interface names found via `(function|class|interface)\s+(\w+)`.
  - `internals`: non-exported `const|let|function|class` names.
  - All returned as string arrays (JSON-serializable).
- `extractAndPersistMetadata(db: Db, repoId: string): void` — Synchronous. Get all chunks for repo grouped by path, merge chunks per file, call `extractFileMetadata` on merged content, upsert into fileMetadata table. Detect language from path extension.
- `extractFileMetadata` is a sync helper — do NOT wrap in lensFn(). `extractAndPersistMetadata` is also sync (called from runIndex orchestrator which is already lensFn-wrapped).

**identity.ts** — Port from v1 (`git show v1-archive:packages/engine/src/repo/identity.ts`):
- `deriveIdentityKey(rootPath: string, remoteUrl?: string): string` — SHA-256 hash of `remoteUrl` if available, else SHA-256 of normalized `rootPath`. Returns hex digest.
- Synchronous, not wrapped in lensFn().

**repo.ts** — Port from v1 (`git show v1-archive:packages/engine/src/repo/repo.ts`):
- `registerRepo(db: Db, rootPath: string, name?: string): RepoRecord` — Validates path is a git repo by calling `getHeadCommit()` (throws if not). Derives identity_key. If repo with same identity_key exists, return it (idempotent). Otherwise insert new row with index_status "pending". Name defaults to directory basename.
- `removeRepo(db: Db, repoId: string): { removed: boolean }` — Delete repo by id. CASCADE deletes all chunks, metadata, imports, stats, cochanges.
- `listRepos(db: Db): RepoRecord[]` — Return all repos.
- `getRepoStatus(db: Db, repoId: string): RepoRecord | null` — Return single repo.
- registerRepo is async (calls getHeadCommit). Wrap in lensFn().
- removeRepo, listRepos, getRepoStatus are sync DB calls. Only wrap the ones exported from the public barrel (index.ts) in lensFn — internal sync helpers stay plain.

Do NOT create `packages/engine/src/index.ts` barrel yet — that is Plan 02-04's responsibility. For now, just ensure each module file compiles and exports are importable by sibling modules.
  </action>
  <verify>
    `pnpm --filter @lens/engine build` succeeds.
    `pnpm --filter @lens/engine typecheck` exits 0.
    Grep for `git ls-files` in discovery.ts confirms git-based scanning.
    Grep for `createHash` in chunker.ts confirms SHA-256 hashing.
    Grep for `export.*function\|export.*const` in repo.ts confirms exports exist.
  </verify>
  <done>
    File discovery via `git ls-files -z` respects .gitignore (ENGN-01). Chunker splits content into 150-line windows. Metadata extractor pulls exports/imports/docstrings/sections/internals. Repo registration creates identity_key and validates git repo. Repo CRUD (register/remove/list) works at the engine level (DAEM-05 engine-side).
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @lens/engine build` exits 0
- `pnpm --filter @lens/engine typecheck` exits 0
- `grep -r "git ls-files" packages/engine/src/` shows discovery.ts
- `grep -r "createHash" packages/engine/src/` shows chunker.ts
- `grep -r "sqliteTable" packages/engine/src/` shows 6 table definitions in schema.ts
- `grep -r "pragma" packages/engine/src/` shows WAL + busy_timeout + foreign_keys in connection.ts
</verification>

<success_criteria>
- Engine package builds and typechecks with all dependencies installed
- 6 Drizzle schema tables defined matching the research spec
- DB connection uses WAL mode, busy_timeout, foreign_keys
- File discovery uses `git ls-files -z` (respects .gitignore natively)
- Chunker produces overlapping 150-line windows with SHA-256 hashes
- Metadata extractor pulls exports, imports, docstring, sections, internals
- Repo registration validates git repo and derives identity key
- Repo CRUD (register/remove/list) works
</success_criteria>

<output>
After completion, create `.planning/phases/02-intelligence-engine/02-01-SUMMARY.md`
</output>
